<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HEIR â€“ Dialects</title><link>https://google.github.io/heir/docs/dialects/</link><description>Recent content in Dialects on HEIR</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://google.github.io/heir/docs/dialects/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: BGV</title><link>https://google.github.io/heir/docs/dialects/bgv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://google.github.io/heir/docs/dialects/bgv/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;p>The BGV dialect defines the types and operations of the BGV cryptosystem.&lt;/p>
&lt;h2 id="bgv-attributes">BGV attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="bgvringsattr">BGVRingsAttr&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#bgv.rings&amp;lt;
::llvm::ArrayRef&amp;lt;::mlir::heir::poly::RingAttr&amp;gt; # rings
&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">rings&lt;/td>
&lt;td style="text-align:center">&lt;code>::llvm::ArrayRef&amp;lt;::mlir::heir::poly::RingAttr&amp;gt;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="bgv-types">BGV types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="ciphertexttype">CiphertextType&lt;/h3>
&lt;p>A type for BGV Ciphertext&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!bgv.ciphertext&amp;lt;
::mlir::heir::bgv::BGVRingsAttr, # rings
unsigned, # dim
std::optional&amp;lt;uint64_t&amp;gt; # level
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A type for BGV Ciphertexts.&lt;/p>
&lt;p>This type tracks the BGV ciphertext parameters, including the ciphertext
dimension (number of polynomials) and the set of rings that were used for
the particular BGV scheme instance. The default dimension is 2, representing
a ciphertext that is canonically encrypted against the key basis &lt;code>(1, s)&lt;/code>.&lt;/p>
&lt;p>The type also includes a ring parameter specification.&lt;/p>
&lt;p>For example, &lt;code>bgv.ciphertext&amp;lt;rings=#rings, dim=3&amp;gt;&lt;/code> is a ciphertext with 3
polynomials (c_0, c_1, c_2).&lt;/p>
&lt;p>The optional attribute &lt;code>level&lt;/code> specifies the &amp;ldquo;current ring&amp;rdquo;.&lt;/p>
&lt;h4 id="parameters-1">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">rings&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::bgv::BGVRingsAttr&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">dim&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">level&lt;/td>
&lt;td style="text-align:center">&lt;code>std::optional&amp;lt;uint64_t&amp;gt;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Comb</title><link>https://google.github.io/heir/docs/dialects/comb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://google.github.io/heir/docs/dialects/comb/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;p>Types and operations for comb dialect
This dialect defines the &lt;code>comb&lt;/code> dialect, which is intended to be a generic
representation of combinational logic outside of a particular use-case.&lt;/p>
&lt;h2 id="operation-definition">Operation definition&lt;/h2>
&lt;h3 id="combadd-heircombaddop">&lt;code>comb.add&lt;/code> (heir::comb::AddOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.add` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands&lt;/p>
&lt;p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)&lt;/p>
&lt;p>Effects: MemoryEffects::Effect{}&lt;/p>
&lt;h4 id="attributes">Attributes:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Attribute&lt;/th>
&lt;th style="text-align:center">MLIR Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>twoState&lt;/code>&lt;/td>
&lt;td style="text-align:center">::mlir::UnitAttr&lt;/td>
&lt;td>unit attribute&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operands">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="comband-heircombandop">&lt;code>comb.and&lt;/code> (heir::comb::AndOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.and` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands&lt;/p>
&lt;p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)&lt;/p>
&lt;p>Effects: MemoryEffects::Effect{}&lt;/p>
&lt;h4 id="attributes-1">Attributes:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Attribute&lt;/th>
&lt;th style="text-align:center">MLIR Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>twoState&lt;/code>&lt;/td>
&lt;td style="text-align:center">::mlir::UnitAttr&lt;/td>
&lt;td>unit attribute&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operands-1">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-1">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combconcat-heircombconcatop">&lt;code>comb.concat&lt;/code> (heir::comb::ConcatOp)&lt;/h3>
&lt;p>&lt;em>Concatenate a variadic list of operands together.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.concat` $inputs attr-dict `:` qualified(type($inputs))
&lt;/code>&lt;/pre>&lt;p>See the comb rationale document for details on operand ordering.&lt;/p>
&lt;p>Traits: AlwaysSpeculatableImplTrait&lt;/p>
&lt;p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)&lt;/p>
&lt;p>Effects: MemoryEffects::Effect{}&lt;/p>
&lt;h4 id="operands-2">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-2">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combextract-heircombextractop">&lt;code>comb.extract&lt;/code> (heir::comb::ExtractOp)&lt;/h3>
&lt;p>&lt;em>Extract a range of bits into a smaller value, lowBit specifies the lowest bit included.&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
&lt;/code>&lt;/pre>&lt;p>Traits: AlwaysSpeculatableImplTrait&lt;/p>
&lt;p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)&lt;/p>
&lt;p>Effects: MemoryEffects::Effect{}&lt;/p>
&lt;h4 id="attributes-2">Attributes:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Attribute&lt;/th>
&lt;th style="text-align:center">MLIR Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lowBit&lt;/code>&lt;/td>
&lt;td style="text-align:center">::mlir::IntegerAttr&lt;/td>
&lt;td>32-bit signless integer attribute&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operands-3">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-3">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combicmp-heircombicmpop">&lt;code>comb.icmp&lt;/code> (heir::comb::ICmpOp)&lt;/h3>
&lt;p>&lt;em>Compare two integer values&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.icmp` (`bin` $twoState^)? $predicate $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
&lt;/code>&lt;/pre>&lt;p>This operation compares two integers using a predicate. If the predicate is
true, returns 1, otherwise returns 0. This operation always returns a one
bit wide result.&lt;/p>
&lt;pre tabindex="0">&lt;code> %r = comb.icmp eq %a, %b : i4
&lt;/code>&lt;/pre>&lt;p>Traits: AlwaysSpeculatableImplTrait, SameTypeOperands&lt;/p>
&lt;p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)&lt;/p>
&lt;p>Effects: MemoryEffects::Effect{}&lt;/p>
&lt;h4 id="attributes-3">Attributes:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Attribute&lt;/th>
&lt;th style="text-align:center">MLIR Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>predicate&lt;/code>&lt;/td>
&lt;td style="text-align:center">::mlir::heir::comb::ICmpPredicateAttr&lt;/td>
&lt;td>hw.icmp comparison predicate&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>twoState&lt;/code>&lt;/td>
&lt;td style="text-align:center">::mlir::UnitAttr&lt;/td>
&lt;td>unit attribute&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operands-4">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lhs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>rhs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-4">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combmul-heircombmulop">&lt;code>comb.mul&lt;/code> (heir::comb::MulOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.mul` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands&lt;/p>
&lt;p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)&lt;/p>
&lt;p>Effects: MemoryEffects::Effect{}&lt;/p>
&lt;h4 id="attributes-4">Attributes:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Attribute&lt;/th>
&lt;th style="text-align:center">MLIR Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>twoState&lt;/code>&lt;/td>
&lt;td style="text-align:center">::mlir::UnitAttr&lt;/td>
&lt;td>unit attribute&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operands-5">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-5">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combmux-heircombmuxop">&lt;code>comb.mux&lt;/code> (heir::comb::MuxOp)&lt;/h3>
&lt;p>&lt;em>Return one or the other operand depending on a selector bit&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.mux` (`bin` $twoState^)? $cond `,` $trueValue `,` $falseValue attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code> %0 = mux %pred, %tvalue, %fvalue : i4
&lt;/code>&lt;/pre>&lt;p>Traits: AlwaysSpeculatableImplTrait&lt;/p>
&lt;p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)&lt;/p>
&lt;p>Effects: MemoryEffects::Effect{}&lt;/p>
&lt;h4 id="attributes-5">Attributes:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Attribute&lt;/th>
&lt;th style="text-align:center">MLIR Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>twoState&lt;/code>&lt;/td>
&lt;td style="text-align:center">::mlir::UnitAttr&lt;/td>
&lt;td>unit attribute&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operands-6">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>cond&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>trueValue&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>falseValue&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-6">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>any type&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combor-heircomborop">&lt;code>comb.or&lt;/code> (heir::comb::OrOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.or` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands&lt;/p>
&lt;p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)&lt;/p>
&lt;p>Effects: MemoryEffects::Effect{}&lt;/p>
&lt;h4 id="attributes-6">Attributes:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Attribute&lt;/th>
&lt;th style="text-align:center">MLIR Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>twoState&lt;/code>&lt;/td>
&lt;td style="text-align:center">::mlir::UnitAttr&lt;/td>
&lt;td>unit attribute&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operands-7">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-7">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combparity-heircombparityop">&lt;code>comb.parity&lt;/code> (heir::comb::ParityOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.parity` (`bin` $twoState^)? $input attr-dict `:` qualified(type($input))
&lt;/code>&lt;/pre>&lt;p>Traits: AlwaysSpeculatableImplTrait&lt;/p>
&lt;p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)&lt;/p>
&lt;p>Effects: MemoryEffects::Effect{}&lt;/p>
&lt;h4 id="attributes-7">Attributes:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Attribute&lt;/th>
&lt;th style="text-align:center">MLIR Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>twoState&lt;/code>&lt;/td>
&lt;td style="text-align:center">::mlir::UnitAttr&lt;/td>
&lt;td>unit attribute&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operands-8">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-8">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combreplicate-heircombreplicateop">&lt;code>comb.replicate&lt;/code> (heir::comb::ReplicateOp)&lt;/h3>
&lt;p>&lt;em>Concatenate the operand a constant number of times&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.replicate` $input attr-dict `:` functional-type($input, $result)
&lt;/code>&lt;/pre>&lt;p>Traits: AlwaysSpeculatableImplTrait&lt;/p>
&lt;p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)&lt;/p>
&lt;p>Effects: MemoryEffects::Effect{}&lt;/p>
&lt;h4 id="operands-9">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>input&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-9">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combtruth_table-heircombtruthtableop">&lt;code>comb.truth_table&lt;/code> (heir::comb::TruthTableOp)&lt;/h3>
&lt;p>&lt;em>Return a true/false based on a lookup table&lt;/em>&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.truth_table` $inputs `-&amp;gt;` $lookupTable attr-dict
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code> %a = ... : i1
%b = ... : i1
%0 = comb.truth_table %a, %b -&amp;gt; [false, true, true, false]
&lt;/code>&lt;/pre>&lt;p>This operation assumes a fully elaborated table &amp;ndash; 2^n entries. Inputs are
sorted MSB -&amp;gt; LSB from left to right and the offset into &lt;code>lookupTable&lt;/code> is
computed from them. The table is sorted from 0 -&amp;gt; (2^n - 1) from left to
right.&lt;/p>
&lt;p>No difference from array_get into an array of constants except for xprop
behavior. If one of the inputs is unknown, but said input doesn&amp;rsquo;t make a
difference in the output (based on the lookup table) the result should not
be &amp;lsquo;x&amp;rsquo; &amp;ndash; it should be the well-known result.&lt;/p>
&lt;p>Traits: AlwaysSpeculatableImplTrait&lt;/p>
&lt;p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)&lt;/p>
&lt;p>Effects: MemoryEffects::Effect{}&lt;/p>
&lt;h4 id="attributes-8">Attributes:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Attribute&lt;/th>
&lt;th style="text-align:center">MLIR Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>lookupTable&lt;/code>&lt;/td>
&lt;td style="text-align:center">::mlir::ArrayAttr&lt;/td>
&lt;td>1-bit boolean array attribute&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operands-10">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-10">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>1-bit signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="combxor-heircombxorop">&lt;code>comb.xor&lt;/code> (heir::comb::XorOp)&lt;/h3>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>operation ::= `comb.xor` (`bin` $twoState^)? $inputs attr-dict `:` qualified(type($result))
&lt;/code>&lt;/pre>&lt;p>Traits: AlwaysSpeculatableImplTrait, Commutative, SameOperandsAndResultType, SameTypeOperands&lt;/p>
&lt;p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)&lt;/p>
&lt;p>Effects: MemoryEffects::Effect{}&lt;/p>
&lt;h4 id="attributes-9">Attributes:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Attribute&lt;/th>
&lt;th style="text-align:center">MLIR Type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>twoState&lt;/code>&lt;/td>
&lt;td style="text-align:center">::mlir::UnitAttr&lt;/td>
&lt;td>unit attribute&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="operands-11">Operands:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Operand&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>inputs&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="results-11">Results:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Result&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>result&lt;/code>&lt;/td>
&lt;td>signless integer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="comb-types">Comb types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit --></description></item><item><title>Docs: EncryptedArith</title><link>https://google.github.io/heir/docs/dialects/encryptedarith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://google.github.io/heir/docs/dialects/encryptedarith/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;p>A dialect for encrypted analogues of builtin types.&lt;/p>
&lt;p>The EncryptedArith dialect defines high level primitive types for FHE. It
is intended to be used in a high level representation of an encrypted
arithmetic program.&lt;/p>
&lt;h2 id="encryptedarith-types">EncryptedArith types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="encinttype">EncIntType&lt;/h3>
&lt;p>Encrypted integer type with arbitrary width&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!enc_arith.enc_int&amp;lt;
unsigned # width
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>An encrypted integer with variable width.&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">width&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: LWE</title><link>https://google.github.io/heir/docs/dialects/lwe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://google.github.io/heir/docs/dialects/lwe/</guid><description>
&lt;h2 id="lwe-attributes">LWE attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="bitfieldencodingattr">BitFieldEncodingAttr&lt;/h3>
&lt;p>An attribute describing encoded LWE plaintexts using bit fields.&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe.bit_field_encoding&amp;lt;
unsigned, # cleartext_start
unsigned # cleartext_bitwidth
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A bit field encoding of an integer describes which contiguous region
of bits a small integer occupies within a larger integer.&lt;/p>
&lt;p>In LWE the plaintexts are integers of a given bit width, and the cleartext
messages are integers of a smaller bit width. A common example might be
3-bit cleartexts inside a 32-bit plaintext. In the CGGI FHE scheme, the
3-bit cleartext might be stored as follows, where 0 denotes a 0 bit, &lt;code>b&lt;/code>
denotes a bit of the cleartext, &lt;code>n&lt;/code> denotes a bit reserved for noise, and
&lt;code>|&lt;/code> is a visual aid to show where the bit fields begin and end.&lt;/p>
&lt;pre tabindex="0">&lt;code> 0|bbb|nn...n
MSB^ ^LSB
&lt;/code>&lt;/pre>&lt;p>The data describing the encoding consists of the starting bit positions of
the cleartext bit field and its width, where the LSB is bit 0 and the MSB
is bit &lt;code>bit_width-1&lt;/code>. So the above example would have starting bit &lt;code>30&lt;/code> and
width &lt;code>3&lt;/code>. The bits preceding (more significant than) the starting bit are
reserved for padding, and the bits following (less significant than) the
ending bit are reserved for noise.&lt;/p>
&lt;p>The presence of this attribute as the &lt;code>encoding&lt;/code> attribute of a tensor
indicates that the tensor is an LWE ciphertext.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;pre tabindex="0">&lt;code>#lwe_encoding = #lwe.poly_coefficient_encoding&amp;lt;cleartext_start=30, cleartext_bitwidth=3&amp;gt;
%lwe_ciphertext = arith.constant &amp;lt;[1,2,3,4]&amp;gt; : tensor&amp;lt;4xi32, #lwe_encoding&amp;gt;
&lt;/code>&lt;/pre>&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">cleartext_start&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">cleartext_bitwidth&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Poly</title><link>https://google.github.io/heir/docs/dialects/poly/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://google.github.io/heir/docs/dialects/poly/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;p>The Poly dialect defines single-variable polynomial types and operations.&lt;/p>
&lt;p>The simplest use of this dialect is to do math in a polynomial ring &lt;code>R[x]&lt;/code>,
where &lt;code>R&lt;/code> is another MLIR integer type like &lt;code>u32&lt;/code>, and lower to &lt;code>arith&lt;/code>.&lt;/p>
&lt;p>More generally, this dialect represent polynomial operations in a quotient
polynomial ring &lt;code>Z/qZ[X]/(f(x))&lt;/code> for some integer &lt;code>q&lt;/code> and polynomial &lt;code>f(x)&lt;/code>.
Polyomials &lt;code>p(x), q(x)&lt;/code> are equal in this ring if they have the same remainder
when dividing by &lt;code>f(x)&lt;/code>. The canonical representative for a polynomial &lt;code>p(x)&lt;/code>
is has degree less than &lt;code>deg(f(x))&lt;/code>. When a modulus is given, ring operations
are polynomial addition and multiplication performed with reductions modulo
&lt;code>f(x)&lt;/code> and &lt;code>q&lt;/code>.&lt;/p>
&lt;h2 id="poly-attributes">Poly attributes&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="polynomialattr">PolynomialAttr&lt;/h3>
&lt;p>An attribute containing a single-variable polynomial.&lt;/p>
&lt;p>#poly = #poly.poly&amp;lt;x**1024 + 1&amp;gt;&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">value&lt;/td>
&lt;td style="text-align:center">&lt;code>Polynomial&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ringattr">RingAttr&lt;/h3>
&lt;p>An attribute specifying a ring.&lt;/p>
&lt;p>An attribute specifying a polynomial quotient ring with integer
coefficients, $\mathbb{Z}/n\mathbb{Z}[x] / (p(x))$.&lt;/p>
&lt;p>&lt;code>cmod&lt;/code> is the coefficient modulus $n$, and &lt;code>ideal&lt;/code> is the ring ideal
$(p(x))$. Because all ideals in a single-variable polynomial ring are
principal, the ideal is defined by a single polynomial.&lt;/p>
&lt;p>#ring = #poly.ring&amp;lt;cmod=1234, ideal=#poly.polynomial&amp;lt;x**1024 + 1&amp;raquo;&lt;/p>
&lt;h4 id="parameters-1">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">cmod&lt;/td>
&lt;td style="text-align:center">&lt;code>APInt&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">ideal&lt;/td>
&lt;td style="text-align:center">&lt;code>Polynomial&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="poly-types">Poly types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="polytype">PolyType&lt;/h3>
&lt;p>An element of a polynomial quotient ring&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!poly.poly&amp;lt;
::mlir::heir::poly::RingAttr # ring
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A type for polynomials in a polynomial quotient ring.&lt;/p>
&lt;h4 id="parameters-2">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">ring&lt;/td>
&lt;td style="text-align:center">&lt;code>::mlir::heir::poly::RingAttr&lt;/code>&lt;/td>
&lt;td>An attribute specifying a ring.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: Secret</title><link>https://google.github.io/heir/docs/dialects/secret/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://google.github.io/heir/docs/dialects/secret/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;p>Secret is a dialect for computations that operate on encrypted data.&lt;/p>
&lt;p>Secret is intended to serve as a scheme-agnostic front-end for the HEIR
ecosystem of dialects. It is supposed to be fully interoperable with the
rest of MLIR via secret.generic, while lower-level HEIR dialects would have
custom types for arithmetic on secret integers of various bit widths.&lt;/p>
&lt;h2 id="secret-types">Secret types&lt;/h2>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="secrettype">SecretType&lt;/h3>
&lt;p>A secret value&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!secret.secret&amp;lt;
Type # valueType
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>A generic wrapper around another MLIR type, representing an encrypted value
but not specifying the manner of encryption. This is useful in HEIR because
the compiler may choose various details of the FHE scheme based on the
properties of the input program, the backend target hardware, and cost
models of the various passes.&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">valueType&lt;/td>
&lt;td style="text-align:center">&lt;code>Type&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item></channel></rss>