<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HEIR â€“ Documentation</title><link>https://google.github.io/heir/docs/</link><description>Recent content in Documentation on HEIR</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://google.github.io/heir/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Getting Started</title><link>https://google.github.io/heir/docs/getting_started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://google.github.io/heir/docs/getting_started/</guid><description>
&lt;h2 id="prerequisites">Prerequisites&lt;/h2>
&lt;ul>
&lt;li>Git&lt;/li>
&lt;li>Bazel&lt;/li>
&lt;li>A C compiler (like gcc or clang)&lt;/li>
&lt;/ul>
&lt;h2 id="clone-and-build-the-project">Clone and build the project&lt;/h2>
&lt;h2 id="optional-run-the-tests">Optional: Run the tests&lt;/h2>
&lt;h2 id="first-example">First example&lt;/h2>
&lt;h2 id="next-steps">Next steps&lt;/h2></description></item><item><title>Docs: Pipelines</title><link>https://google.github.io/heir/docs/pipelines/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://google.github.io/heir/docs/pipelines/</guid><description>
&lt;p>The &lt;code>--heir-tosa-to-arith&lt;/code> pipeline lowers a TOSA MLIR model to one that only
contains arithmetic operations via a TOSA to &lt;code>linalg&lt;/code> lowering path. As part of
this lowering, &lt;code>tensor&lt;/code> values are lowered to &lt;code>memref&lt;/code>s. This introduces
&lt;code>memref&lt;/code>s that hold intermediate computation. To simplify the model, we can
inline global constant &lt;code>memref&lt;/code>s, expand &lt;code>memref&lt;/code> aliasing and copy operations
and then forward values through the model using the &lt;code>AffineScalarReplacement&lt;/code>
passes.&lt;/p>
&lt;p>The pass pipeline assumes that the model is a valid TOSA MLIR model with
stripped quantized types. The
&lt;a href="https://openxla.github.io/iree/getting-started/tflite/">iree-import-tflite&lt;/a>
tool can lower a TFLite FlatBuffer to textual MLIR with
&lt;code>--output-format=mlir-ir&lt;/code>. See
&lt;a href="../tests/hello_world.tosa.mlir">hello_world.tosa.mlir&lt;/a> for an example.&lt;/p></description></item><item><title>Docs: Tutorials</title><link>https://google.github.io/heir/docs/tutorials/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://google.github.io/heir/docs/tutorials/</guid><description>
&lt;p>A list of tutorials by the HEIR community.&lt;/p></description></item><item><title>Docs: EncryptedArithTypes Dialect</title><link>https://google.github.io/heir/docs/dialects/encryptedarithtypes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://google.github.io/heir/docs/dialects/encryptedarithtypes/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="encinttype">EncIntType&lt;/h3>
&lt;p>Encrypted integer type with arbitrary width&lt;/p>
&lt;p>Syntax:&lt;/p>
&lt;pre tabindex="0">&lt;code>!enc_arith.enc_int&amp;lt;
unsigned # width
&amp;gt;
&lt;/code>&lt;/pre>&lt;p>An encrypted integer with variable width.&lt;/p>
&lt;h4 id="parameters">Parameters:&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Parameter&lt;/th>
&lt;th style="text-align:center">C++ type&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">width&lt;/td>
&lt;td style="text-align:center">&lt;code>unsigned&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Docs: MemrefToArith Passes</title><link>https://google.github.io/heir/docs/passes/memreftoarith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://google.github.io/heir/docs/passes/memreftoarith/</guid><description>
&lt;!-- Autogenerated by mlir-tblgen; don't manually edit -->
&lt;h3 id="-expand-copy">&lt;code>-expand-copy&lt;/code>&lt;/h3>
&lt;p>&lt;em>Expands memref.copy ops to explicit affine loads and stores&lt;/em>&lt;/p>
&lt;p>This pass removes memref copy operations by expanding it to affine loads and
stores. This pass introduces affine loops over the dimensions of the MemRef,
so must be run prior to any affine loop unrolling in a pipeline.&lt;/p>
&lt;h3 id="-memref-global-replace">&lt;code>-memref-global-replace&lt;/code>&lt;/h3>
&lt;p>&lt;em>MemrefGlobalReplacePass forwards global memrefs accessors to arithmetic values&lt;/em>&lt;/p>
&lt;p>This pass forwards constant global MemRef values to referencing affine
loads. This pass requires that the MemRef global values are initialized as
constants and that the affine load access indices are constants (i.e. not
variadic). Unroll affine loops prior to running this pass.&lt;/p>
&lt;p>MemRef removal is required to remove any memory allocations from the input
model (for example, TensorFlow models contain global memory holding model
weights) to support FHE transpilation.&lt;/p>
&lt;h3 id="-unroll-and-forward">&lt;code>-unroll-and-forward&lt;/code>&lt;/h3>
&lt;p>&lt;em>Loop unrolls and forwards stores to loads.&lt;/em>&lt;/p>
&lt;p>This pass proceses the first function in a given module, and, starting from
the first loop, iteratively does the following:&lt;/p>
&lt;ol>
&lt;li>Fully unroll the loop.&lt;/li>
&lt;li>Scan for load ops. For each load op with a statically-inferrable access
index:&lt;/li>
&lt;li>Backtrack to the original memref alloc&lt;/li>
&lt;li>Find all store ops at the corresponding index (possibly transitively
through renames/subviews of the underlying alloc).&lt;/li>
&lt;li>Find the last store that occurs and forward it to the load.&lt;/li>
&lt;li>If the original memref is an input memref, then forward through any
renames to make the target load load directly from the argument memref
(instead of any subviews, say)&lt;/li>
&lt;li>Apply the same logic to any remaining loads not inside any for loop.&lt;/li>
&lt;/ol>
&lt;p>This pass requires that tensors are lowered to memref, and only supports
affine loops with affine.load/store ops.&lt;/p>
&lt;p>Memrefs that result from memref.get_global ops are excluded from
forwarding, even if they are loaded with a static index, and are instead
handled by memref-global-replace, which should be run after this pass.&lt;/p></description></item><item><title>: Search Results</title><link>https://google.github.io/heir/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://google.github.io/heir/search/</guid><description/></item></channel></rss>